1~20: 변수 · 자료형 · 상수

변수를 선언한다는 것은 무엇을 의미하는가?
👉 값 저장용 메모리 공간에 이름과 자료형을 부여해 사용 범위를 정의하는 행위다.

기본형과 참조형의 차이를 설명하라.
👉 기본형은 값 자체를, 참조형은 객체의 주소(참조)를 저장한다.

int a = 5;에서 int가 의미하는 바는?
👉 32비트 정수를 저장하는 자료형으로, 변수 a에 4바이트 공간을 할당한다.

상수를 선언하는 방법과 의미는?
👉 final 키워드 사용; 이후 값 변경 불가한 읽기 전용 변수다.

String이 기본형이 아닌 이유는?
👉 String은 클래스이자 불변 객체로, 메소드와 상태를 가지는 참조형이기 때문이다.

형변환이 필요한 경우는 언제인가?
👉 서로 다른 자료형 간 연산·대입 시 타입 호환을 맞출 때 필요하다.

묵시적/명시적 형변환의 차이는?
👉 작은 범위→큰 범위는 자동(묵시), 반대는 개발자가 캐스트 연산자로 명시한다.

double r = 10/4;가 2.0이 되는 이유는?
👉 정수 나눗셈 결과 2가 double로 저장되며 2.0이 된다.

변수의 스코프란 무엇인가?
👉 변수가 접근 가능한 코드 블록의 범위다.

지역변수와 필드의 차이는?
👉 지역변수는 블록 내 일시적, 필드는 객체(또는 클래스) 생명주기 동안 유지된다.

null 참조가 의미하는 바는?
👉 어떤 객체도 가리키지 않는 상태로, 접근 시 NPE 위험이 있다.

초기화되지 않은 지역변수 사용 시 결과는?
👉 컴파일 에러; 지역변수는 사용 전 초기화 필수다.

식별자(변수명) 규칙을 2가지 쓰라.
👉 숫자 시작 불가, 공백 불가, 예약어 불가, 대소문자 구분.

상수명 표기 관례는?
👉 대문자 스네이크 케이스: MAX_SIZE.

Wrapper 클래스가 필요한 이유는?
👉 기본형을 객체로 다루어 컬렉션/제네릭에 저장하거나 유틸 메소드를 활용하기 위해.

오토박싱/언박싱을 설명하라.
👉 기본형↔래퍼 자동 변환; 예: int↔Integer.

final int A=10;의 특성은?
👉 재할당 불가한 상수이며, 컴파일러가 상수 전개할 수 있다.

char의 크기와 저장 값은?
👉 2바이트; 하나의 유니코드 문자.

boolean이 가질 수 있는 값은?
👉 true 또는 false만.

static 변수의 특징은?
👉 클래스 단위로 하나만 존재하며 모든 인스턴스가 공유한다.

21~40: 연산자 · 우선순위

++a와 a++의 차이를 설명하라.
👉 전위는 먼저 증가 후 사용, 후위는 사용 후 증가.

==와 equals()의 차이는?
👉 ==는 주소/원시값 비교, equals()는 내용 동등성 비교.

&&와 &의 차이는?
👉 &&는 단락 평가하는 논리연산, &는 비트연산(또는 양쪽 모두 평가).

true || false && false의 값은?
👉 && 우선 → false, 이후 true || false → true.

삼항연산자의 구조를 설명하라.
👉 조건 ? 값1 : 값2; 조건 참이면 값1, 거짓이면 값2.

나머지 연산자 %의 활용 예를 드시오.
👉 짝/홀 판별, 주기적 패턴, 버킷 인덱싱 등.

복합대입 연산자의 장점은?
👉 간결성·가독성 향상과 중복 평가 감소.

비교연산 결과의 자료형은?
👉 항상 boolean.

! 연산자의 의미는?
👉 논리 부정: true↔false.

2 + 3 + "4"가 "54"인 이유는?
👉 좌결합; 정수합 5 후 문자열 결합.

비트 OR |와 XOR ^의 차이는?
👉 OR은 둘 중 하나 1이면 1, XOR은 서로 다를 때 1.

<<와 >>의 효과는?
👉 왼시프트는 2배씩 곱, 오른시프트는 2로 나눔(부호 유지).

a > b ? a : b의 의미는?
👉 두 수 중 큰 값 선택.

연산자 우선순위가 중요한 이유는?
👉 계산 순서가 결과를 바꾸기 때문.

++x와 x += 1의 차이는?
👉 의미는 동일하나 ++가 더 간결하고 표현적이다.

x != y의 의미를 설명하라.
👉 값이 다르면 참, 같으면 거짓.

a = b = 5;가 가능한 이유는?
👉 대입 결과가 오른쪽에서 왼쪽으로 전달되기 때문이다.

정수 나눗셈에서 소수부가 사라지는 이유는?
👉 피연산자·결과가 정수형이기 때문.

instanceof의 용도는?
👉 런타임에 객체의 실제 타입 검사.

문자열 비교에 ==를 쓰면 안 되는 이유는?
👉 참조 비교라 내용 동일성 보장 불가; equals() 사용.

41~60: 조건문 · 반복문

if문의 역할을 설명하라.
👉 조건이 참일 때만 블록을 실행해 흐름을 분기한다.

if-else와 단독 if의 차이는?
👉 if-else는 참/거짓 모두 경로, 단독 if는 참일 때만 실행.

switch에 적합한 사용 사례는?
👉 명확한 이산 값 분기(메뉴 번호, 열거형)에 적합.

switch에서 허용되는 표현식 타입은?
👉 byte, short, int, char, String, enum(래퍼 포함).

switch의 break 생략 시 결과는?
👉 fall-through로 다음 case가 연속 실행된다.

for와 while의 차이는?
👉 for는 반복 제어가 헤더에 응축, while은 조건 중심 반복.

do-while이 필요한 상황은?
👉 최소 한 번 실행 후 조건 확인해야 할 때.

break와 continue의 차이는?
👉 break는 반복 종료, continue는 다음 반복으로 건너뜀.

중첩 반복문 사용 시 주의점은?
👉 시간 복잡도 증가와 가독성 저하를 관리해야 한다.

무한 루프를 만드는 패턴 두 가지는?
👉 for(;;){}와 while(true){}.

1부터 N까지 합을 구하는 반복 전략은?
👉 누적 변수에 반복적으로 더하거나 수식 N(N+1)/2 사용.

루프 불변식이란 무엇인가?
👉 반복마다 항상 참인 조건으로, 정확성 증명에 사용된다.

for-each(향상된 for)의 장점과 한계는?
👉 간결하지만 인덱스 접근·수정에는 부적합.

루프에서 리소스 해제가 필요한 이유는?
👉 반복 중 누수·핸들 고갈을 방지하기 위해.

while 루프 종료 조건 설계 시 유의점은?
👉 조건이 언젠가 거짓이 되도록 상태 변화 보장.

이터레이션 중 컬렉션 구조 변경 시 위험은?
👉 ConcurrentModificationException 발생 가능.

label이 붙은 break의 용도는?
👉 바깥 루프까지 한 번에 탈출.

switch에서 default의 의미는?
👉 어떤 case도 매칭되지 않을 때의 처리 분기.

루프 성능 개선 기법 하나를 제시하라.
👉 불변 계산 사전 추출(루프 외부로 hoist).

상태 기계(state machine)로 루프를 구성하는 이점은?
👉 복잡한 분기를 명확한 상태 전이로 구조화한다.

61~80: 배열 · 객체배열 · String

배열 선언/생성/초기화를 설명하라.
👉 선언: int[] a; 생성: a=new int[3]; 초기화: 리터럴/반복 대입.

배열의 기본 초기값은?
👉 숫자 0, boolean은 false, 참조는 null.

인덱스 범위를 벗어나면 어떤 예외가 나는가?
👉 ArrayIndexOutOfBoundsException.

배열 길이를 구하는 방법은?
👉 arr.length 필드.

배열 복사 방법 3가지는?
👉 반복문, System.arraycopy, Arrays.copyOf.

가변 길이 배열(2차원 비정방)의 이점은?
👉 각 행의 길이를 다르게 해 메모리·성능 최적화.

배열과 ArrayList의 차이는?
👉 배열은 고정 길이, 리스트는 동적 크기/유틸 메소드 제공.

객체배열에서 요소를 생성하지 않으면 무엇이 저장되는가?
👉 각 요소는 null 참조다.

객체배열에서 NPE를 방지하려면?
👉 요소 null 검사 후 메소드 호출.

배열 정렬 방법을 한 가지 제시하라.
👉 Arrays.sort(arr) 또는 커스텀 비교자 사용.

객체배열 초기화 두 가지 방법은?
👉 리터럴 {new A(), new A()} 또는 루프 내 new로 개별 생성.

깊은 복사와 얕은 복사의 차이는?
👉 얕은 복사는 참조만 복제, 깊은 복사는 내부 객체까지 새로 복제.

String이 불변(immutable)인 이점은?
👉 스레드 안전·해시 안정·보안성이 높다.

문자열 결합 시 StringBuilder를 쓰는 이유는?
👉 가변 버퍼로 중간 객체 생성을 줄여 성능이 좋다.

equals와 compareTo의 차이는?
👉 동등성 vs 정렬 순서를 위한 비교(음수/0/양수 반환).

문자 인코딩 변환이 필요한 이유는?
👉 바이트↔문자 매핑 차이로 데이터 손상을 방지하기 위해.

Arrays.equals와 ==의 차이는?
👉 Arrays.equals는 내용 비교, ==는 참조 비교.

다차원 배열 순회 시 캐시 적중률을 높이는 방법은?
👉 행 우선(메모리 연속) 순서로 접근.

Arrays.asList의 제약은?
👉 고정 크기 뷰로 add/remove 불가.

배열을 불변뷰로 노출하는 방법은?
👉 복사본 반환 또는 List.copyOf/Collections.unmodifiableList.

81~100: 클래스 · 캡슐화 · 생성자 · static

클래스와 객체의 차이를 설명하라.
👉 클래스는 설계도, 객체는 설계도로 만든 실체(인스턴스).

캡슐화의 장점은?
👉 내부 구현 은닉·불변식 유지·결합도 감소.

접근제한자 private의 의미는?
👉 같은 클래스 내부에서만 접근 가능.

게터/세터의 역할은?
👉 필드 접근을 제어하고 유효성 검사를 적용한다.

생성자의 역할은?
👉 객체 초기 상태를 설정하고 불변식을 확립한다.

기본 생성자가 자동 생성되는 경우는?
👉 개발자가 어떤 생성자도 정의하지 않았을 때.

오버로딩과 오버라이딩의 차이는?
👉 오버로딩은 시그니처 다른 동일 이름 메소드, 오버라이딩은 상속받은 메소드 재정의.

this 키워드의 두 가지 용도는?
👉 현재 인스턴스 참조, 같은 이름 매개변수/필드 구분.

this()와 super()의 차이는?
👉 같은 클래스 다른 생성자 호출 vs 부모 생성자 호출.

static 메소드의 제약은?
👉 인스턴스 필드/메소드에 직접 접근 불가.

불변(immutable) 객체를 만드는 요건은?
👉 필드 final, 가변 필드 방어적 복사, 변경 메소드 미제공.

메소드 시그니처란?
👉 메소드명 + 매개변수 타입 목록(리턴·예외는 제외).

toString()을 재정의하는 이유는?
👉 객체 상태를 읽기 쉬운 문자열로 제공해 디버깅/로그에 유용.

equals 재정의 시 hashCode도 재정의해야 하는 이유는?
👉 동등한 객체는 동일 해시를 가져야 해 해시 기반 컬렉션 불변식을 만족.

가시성(접근제한)과 변경 가능성(mutability)을 구분해 설계해야 하는 이유는?
👉 외부 오용 방지와 일관성/스레드 안전성 확보를 위해.

정적 초기화 블록의 용도는?
👉 클래스 로딩 시 한 번만 수행할 초기화 로직.

메소드 체이닝을 가능케 하는 패턴은?
👉 this 반환하는 플루언트 인터페이스.

레코드(Record)의 장점은?
👉 보일러플레이트 없이 불변 데이터 캐리어를 간단히 정의.

내부 클래스의 이점은?
👉 외부 클래스와 밀접한 로직을 캡슐화하고 가독성을 높인다.

익명 클래스가 유용한 상황은?
👉 인터페이스/추상클래스의 일회성 구현이 필요할 때.

101~120: 상속 · 다형성 · 추상 · 인터페이스

상속의 장점 두 가지는?
👉 코드 재사용, 다형성 지원.

extends의 의미는?
👉 부모의 필드/메소드를 자식이 물려받아 확장한다는 선언.

오버라이딩 조건을 기술하라.
👉 동일 시그니처, 더 넓은 접근, 같은/하위 반환타입, 예외는 같거나 좁게.

super 키워드의 역할은?
👉 부모 멤버 접근 및 부모 생성자 호출.

final 클래스/메소드의 의미는?
👉 클래스는 상속 불가, 메소드는 오버라이딩 불가.

단일 상속의 장단점은?
👉 다이아몬드 문제 회피/구조 단순 vs 표현력 제한.

다형성이란 무엇인가?
👉 같은 인터페이스로 서로 다른 구체 타입을 동일하게 다루는 성질.

업캐스팅/다운캐스팅 차이는?
👉 자식→부모(안전, 묵시적)/부모→자식(명시적, instanceof 확인 필요).

동적 바인딩이란?
👉 실제 객체 타입에 따라 실행 시점에 메소드가 결정되는 것.

추상 클래스와 인터페이스의 차이는?
👉 추상 클래스는 상태+일부 구현 가질 수 있고 단일 상속; 인터페이스는 계약 중심, 다중 구현 가능.

인터페이스의 default 메소드 목적은?
👉 기존 구현체 호환성 유지하며 공통 기본 구현 제공.

전략 패턴이 다형성을 활용하는 방식은?
👉 공통 인터페이스로 알고리즘을 교체 가능하게 캡슐화.

템플릿 메소드 패턴에서 추상 메소드의 역할은?
👉 변하는 부분을 하위 클래스에 위임해 골격 알고리즘을 유지.

instanceof 남용이 해로운 이유는?
👉 다형성 위반으로 조건 분기 남발과 결합도 상승.

LSP(리스코프 치환 원칙)를 설명하라.
👉 부모 타입 자리에는 자식 타입을 대체해도 행동적 일관성이 유지되어야 한다.

인터페이스 분리 원칙(ISP)이 의미하는 바는?
👉 클라이언트별로 작은 인터페이스를 제공해 불필요한 의존을 줄인다.

합성(composition)이 상속보다 선호되는 이유는?
👉 런타임 교체·캡슐화·결합도 감소로 유연성이 크다.

공변 반환 타입의 의미는?
👉 오버라이딩 시 더 구체적인 반환 타입을 허용.

다중 구현(여러 인터페이스 구현)의 주의점은?
👉 메소드 시그니처 충돌 시 명시적 구현/디자인 조정 필요.

추상 클래스에서 필드 사용 시 주의점은?
👉 하위 클래스 초기화 순서와 불변식 위반을 조심해야 한다.

121~140: 예외 처리 · 컬렉션 · 제네릭 · I/O

예외와 오류의 차이는?
👉 예외는 회복 가능 상황, 오류는 시스템적·회복 불가 상황.

try-catch-finally의 실행 순서를 설명하라.
👉 try 실행→예외 시 맞는 catch→finally는 항상 실행(자원 해제).

체크드/언체크드 예외 차이는?
👉 체크드는 선언/처리 강제, 언체크드는 런타임 발생·선언 강제 아님.

throw vs throws의 차이는?
👉 throw는 예외 발생, throws는 메소드가 예외를 던질 수 있음을 선언.

사용자 정의 예외 만드는 법은?
👉 Exception 또는 RuntimeException 상속하여 생성자 정의.

다중 catch에서 순서가 중요한 이유는?
👉 상위 타입이 먼저 오면 하위가 도달 불가(컴파일 에러).

finally가 생략되면 어떻게 자원을 닫는가?
👉 try-with-resources 사용으로 자동 해제.

NPE를 예방하는 일반 원칙은?
👉 방어적 코딩(null 체크), 불변 객체, Optional/계약 보장.

equals/hashCode 미준수 시 컬렉션에서 생길 문제는?
👉 중복·검색 실패·버킷 오작동으로 논리 오류.

List/Set/Map의 핵심 차이는?
👉 List: 순서·중복 허용, Set: 중복 불가, Map: 키-값 매핑.

HashMap vs TreeMap 차이는?
👉 HashMap은 해시 기반 O(1) 평균, TreeMap은 정렬 O(logN).

ArrayList vs LinkedList 차이는?
👉 ArrayList 랜덤 접근 빠름, LinkedList 삽입/삭제 위치 기반 유리.

HashSet의 중복 판단 기준은?
👉 hashCode와 equals 결과.

제네릭 사용의 장점은?
👉 타입 안정성·캐스팅 제거·가독성 향상.

와일드카드 ? extends T와 ? super T의 의미는?
👉 extends는 읽기 전용 공변, super는 쓰기 허용 반공변.

I/O에서 바이트 스트림과 문자 스트림 차이는?
👉 바이트는 원시 바이트 처리, 문자는 인코딩 인지 문자 처리.

버퍼링의 이점은?
👉 시스템 호출 횟수 감소로 성능 향상.

직렬화의 목적은?
👉 객체 상태를 바이트로 변환해 저장/전송/복원을 가능케 함.

transient 키워드의 역할은?
👉 특정 필드를 직렬화 대상에서 제외.

파일 읽기/쓰기 시 반드시 고려할 점은?
👉 자원 해제, 예외 처리, 인코딩 명시, 경로 보안.

141~150: 스레드 · 동시성 · JVM · 기타

프로세스와 스레드의 차이는?
👉 프로세스는 자원 단위, 스레드는 실행 흐름 단위(프로세스 내 메모리 공유).

Thread 상속 vs Runnable 구현의 차이는?
👉 상속은 확장성 제약, Runnable은 조합 유리·다중 상속 회피.

synchronized의 역할은?
👉 임계구역 상호배제를 보장해 경쟁 상태를 방지.

데드락이 발생하는 조건을 설명하라.
👉 상호 배제, 보유-대기, 비선점, 순환 대기.

wait/notify의 용도는?
👉 모니터 락 기반 조건 대기·깨우기(생산자-소비자).

불변 객체가 동시성에 유리한 이유는?
👉 상태가 변하지 않아 락 없이도 안전하게 공유 가능.

JVM 메모리 구조(주요 영역)를 설명하라.
👉 메서드 영역, 힙, 스택, 네이티브 메서드 스택, PC 레지스터.

GC의 기본 역할과 장점은?
👉 도달 불가능 객체 회수로 메모리 자동 관리·누수 감소.

JDK/JRE/JVM의 차이는?
👉 JVM은 실행 엔진, JRE는 실행 환경, JDK는 개발 도구 포함한 전체 묶음.

자바가 플랫폼 독립적인 이유는?
👉 바이트코드를 JVM이 각 플랫폼에서 해석/최적화 실행하기 때문(“Write Once, Run Anywhere”).